{
    "collab_server" : "",
    "contents" : "#Instalando os pacotes\ninstall.packages(\"caret\")\ninstall.packages(\"rpart\")\ninstall.packages(\"rpart.plot\")\n\n#Importando\nlibrary(caret)\nlibrary(rpart)\nlibrary(rpart.plot)\n\n#Baixando os dados\ndata(\"iris\")\n\n#Dar uma olhada na estrura e nos dados\nstr(iris)\nsummary(iris)\n\n#Vou dividir o conjunto de dados em input (X) e output (y).\n#Nesse caso, os inputs são as quatro dimensões (comprimento da sépala, largura da sépala,\n#comprimento da pétala e largura da pétala) e o output é a espécie da planta.\nX <- iris[, 1:4]   #O espaço em branco antes da vírgula indica que quero selecionar todas as linhas do conjunto de dados.\n                   #1:4 especifica as colunas a serem selecionadas, que são as colunas 1, 2, 3 e 4 do conjunto de dados da íris.\n                   #As quatro dimensões (comprimento da sépala, largura da sépala, comprimento da pétala e largura da pétala) são representadas por essas quatro colunas no conjunto de dados da íris\ny <- iris$Species\n\n#Para avaliar o desempenho do modelo, vou dividir os dados em treinamento e teste.\n#O treinamento será usado para treinar o modelo e o conjunto de teste será\n#usado para avaliar sua precisão.Descobri que se usa o pacote caret para dividir os dados.\n\nset.seed(123) #Aqui, defini uma semente aleatória para garantir a reprodutibilidade dos resultados. \n              #Definindo isso, uma semente nos permite obter as mesmas divisões aleatórias toda vez que o código é executado.\n\ntrain_index <- createDataPartition(y, p = 0.7, list = FALSE) #A variável y representa o output.\n                                                             #O argumento p é definido como 0,7,indicando que quero 70% dos dados para treinamento.\n\n#Separando os dados em dois conjuntos: X_train e y_train para treinar o modelo e X_test e y_test para avaliar o desempenho do modelo em dados não vistos. \n#O conjunto de treinamento é usado para construir o modelo, enquanto o conjunto de teste é usado para avaliar o quão bem o modelo generaliza para dados novos e não vistos.\nX_train <- X[train_index, ]  #\"train_index\" contém as observações que serão utilizadas para treinar o modelo.\n                             #X[train_index, ] seleciona as linhas do conjunto de dados X correspondentes aos índices em train_index.\n                             #Isso cria um subconjunto do conjunto de dados original X, contendo apenas as observações que serão usadas para treinar o modelo.\n                             #O subconjunto é atribuído à variável X_train, representando os recursos de treinamento.\ny_train <- y[train_index]    \n\nX_test <- X[-train_index, ]  #[-train_index] seleciona as linhas do conjunto de dados X que não estão incluídas no train_index.\n                             #Isso cria um subconjunto do conjunto de dados original X, contendo as observações que serão usadas para testar o modelo.\n                             #O subconjunto é atribuído à variável X_test, representando os recursos de teste.\ny_test <- y[-train_index]    \n\n#A função rpart() do pacote rpart foi usada para treinar o modelo de árvore de decisão. \n#Ele usa os dados de treinamento (X_train e y_train) e a fórmula y_train ~ . para especificar\n#que a espécie (y_train) deve ser prevista com base em todas as outras variáveis (comprimento da\n#sépala, largura da sépala, comprimento da pétala e largura da pétala).\nmodel <- rpart(y_train ~ ., data = X_train) \n\nrpart.plot(model) #minha árvore que lindinha\n\n#A função predict() é usada para fazer previsões nos dados de teste (X_test) usando o modelo treinado.\n#O argumento \"type = \"class\" especifica que os valores previstos devem ser as classes.\npredictions <- predict(model, X_test, type = \"class\")\n\n#A função confusionMatrix() do pacote caret é usada para calcular a confusion matrix e outras\n#métricas de desempenho. Ele usa os valores previstos (previsões) e os rótulos reais (y_test) como input.\nconfusion_matrix <- confusionMatrix(predictions, y_test)\n\n#A precisão é extraída do objeto confusion_matrix usando o componente $overall e o índice 'Accuracy'.\naccuracy <- confusion_matrix$overall['Accuracy']\n\nprint(confusion_matrix)\nprint(accuracy)\n\n# Convertendo a confusion matrix para data frame\nconfusion_df <- as.data.frame(confusion_matrix$table)\n\n#gráfico de gradiente de calor\n# Vou renomear as coluna no data frame\ncolnames(confusion_df) <- c(\"Referência\", \"Predição\", \"n\")\n\n# Plot the confusion matrix as a heatmap\nggplot(confusion_df, aes(x = Referência, y = Predição, fill = n)) +\n  geom_tile() +                                                      #A função geom_tile() cria blocos coloridos\n                                                                     #representando os valores na confuion matrix.\n  geom_text(aes(label = n), color = \"white\") +                       #A função geom_text() adiciona nome aos blocos.\n  scale_fill_gradient(low = \"lightblue\", high = \"darkblue\") +        #A função scale_fill_gradient() define o gradiente de cores.\n  labs(x = \"Referência\", y = \"Predição\", title = \"Confusion Matrix\") #A função labs() define os nome no gráfico.\n\n#gráfico de barras #ficou estranho vou arrumar depois\ncolnames(confusion_df) <- c(\"Referência\", \"Predição\", \"Contagem\")\n\nggplot(confusion_df, aes(x = Referência, y = Contagem, fill = Predição)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +                     #A função geom_bar() cria um gráfico de barras\n                                                                        #com os valores previstos (Previsão) como cores \n                                                                        #de preenchimento.\n  labs(x = \"Referência\", y = \"Contagem\", title = \"Confusion Matrix\") +  #O argumento \"position = \"dodge\"\" posiciona as \n                                                                        #barras lado a lado.\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))              #A função theme() é usada para personalizar a \n                                                                        #aparência do gráfico, girando os rótulos do eixo x.\n",
    "created" : 1684533255994.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "645790086",
    "id" : "F56B5908",
    "lastKnownWriteTime" : 1684543800,
    "last_content_update" : 1684543800345,
    "path" : "~/Predição de Iris/Script.R",
    "project_path" : "Script.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}